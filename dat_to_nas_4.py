# -*- coding: utf-8 -*-
"""
This program converts a .dat file from the SolidWorks format to the format
required by Petra-M
"""

import numpy as np
import matplotlib.pyplot as plt
import mmap
import itertools
import math

#Filepaths
bodyFilePath='C:/Users/kunalsanwalka/Documents/UCLA/BAPSF/rings_body.dat'
shellFilePath='C:/Users/kunalsanwalka/Documents/UCLA/BAPSF/rings_shell.dat'
formattedFilePath='C:/Users/kunalsanwalka/Documents/UCLA/BAPSF/rings_formatted.txt'
formattedFilePath2='C:/Users/kunalsanwalka/Documents/UCLA/BAPSF/rings_formatted2.nas'

#Whitespace array
wSpace=['',' ','  ','   ','    ','     ','      ','       ','        ','         ','          ','           ','            ','             ','              ','               ','                ']

#Files to write to
writeFile=open(formattedFilePath,'w')
writeFile2=open(formattedFilePath2,'w')

#Write the opening lines into the file
writeFile.write('$ Generated by dat_to_nas\n')
writeFile.write('BEGIN BULK\n')

#Flags to add a comment line at the start of the data section
gridFlag=False
ctetraFlag=False
ctriaFlag=False
pshellFlag=False

#In case I want to print a line after the lines have all been read
debugLine=''

#Stores all of the missing points
mPoints=[]

#Open the shell file and body file to allow for searching
bodyFileObj=open(bodyFilePath)
shellFileObj=open(shellFilePath)
bodyFile=mmap.mmap(bodyFileObj.fileno(),0,access=mmap.ACCESS_READ)
shellFile=mmap.mmap(shellFileObj.fileno(),0,access=mmap.ACCESS_READ)

def numConv(dataString,numDecimalPlaces):
    #Get the base
    baseStr=dataString[:-3]
    #Get the exponent
    expStr=dataString[-3:]
    #Convert to numbers
    baseNum=float(baseStr)
    expNum=float(expStr)
    #Find the actual value
    fullNum=baseNum*(10**expNum)
    num=round(fullNum,numDecimalPlaces)
    return num

def distPoints(point1,point2):
    sqArr=[]
    #Square the difference in each direction
    for i in range(0,len(point1)):
        sqArr.append((point1[i]-point2[i])**2)
    dist=0
    #Add the squared values
    for elem in sqArr:
        dist+=elem
    return math.sqrt(dist)

def arrEq(array1,array2):
    #Check if they have the same length
    if len(array1)!=len(array2):
        return False
    #Sort the arrays
    array1.sort()
    array2.sort()
    #Check each element
    for i in range(0,len(array1)):
        if array1[i]!=array2[i]:
            return False
    return True

#Open the file with the body data
with open(bodyFilePath) as file:
    for line in file:        
#        print(line)
        
        #Split each line into an array
        data=line.split(',')
        #Delete unnecessary values
        data=list(filter(None,data))
        for item in data:
            if item=='\n':
                data.remove(item)
                
#        print(data)
        
        #Store the data to be written to the formatted file
        dataLine=''
        dataLine2='' #For rollover elements
            
        #Create data lines for GRID
        if data[0]=='GRID':
            #Add the starting comment to indicate GRID data
            if gridFlag==False:
                writeFile.write('$ Grid data section\n')
                gridFlag=True
            
            #Make the data long field format
            dataLine+='GRID    '
            for i in range(1,len(data)):
                if i==2:
                    dataLine+=wSpace[8]
                elif i>=3 and i<=5:
                    if len(dataLine)<72:
                        numToAdd=numConv(data[i],5)
                        dataLine+=wSpace[8-len(str(numToAdd))]
                        dataLine+=str(numToAdd)
                    elif len(dataLine)==72:
                        dataLine+=' *GRID10'
                        dataLine2+='*GRID10 '
                    if len(dataLine2)>0:
                        dataLine2+=wSpace[16-len(data[i])]
                        dataLine2+=data[i]
                else:
                    if len(dataLine)<72:
                        dataLine+=wSpace[8-len(data[i])]
                        dataLine+=data[i]
                    elif len(dataLine)==72:
                        dataLine+=' *GRID10'
                        dataLine2+='*GRID10 '
                    if len(dataLine2)>0:
                        dataLine2+=wSpace[16-len(data[i])]
                        dataLine2+=data[i]
#            print(dataLine)
#            print(dataLine2)
            
            #Write GRID to file
            finalLine=dataLine+'\n'
            if len(dataLine2)==0:
                writeFile.write(finalLine)
            elif len(dataLine2)>0:
                writeFile.write(finalLine)
                addLine=dataLine2+'\n'
                writeFile.write(addLine)
        
        #Create data lines for CTETRA
        elif data[0]=='CTETRA' or len(data)==4:
            #Add the starting comment to indicate CTETRA data
            if ctetraFlag==False:
                writeFile.write('$ Element data section\n')
                ctetraFlag=True
                
            if data[0]=='CTETRA':
                dataLine='CTETRA  '
                for i in range(1,len(data)):
                    if len(dataLine)<72:
                        dataLine+=wSpace[8-len(data[i])]
                        dataLine+=data[i]
                    elif len(dataLine)==72:
                        dataLine+='+CONT'
                        dataLine2+='+CONT   '
#                print(dataLine)
            #Add the end and beginning markers for the next line
            if len(dataLine)==72 and len(dataLine)!=77:
                dataLine+='+CONT'
#                print(dataLine)
#                debugLine=dataLine2            
            if len(data)==4:
                dataLine2+='+CONT   '
                for i in range(0,len(data)):
                    #I don't know why I have to use this if-else and make it 9
                    #for the last one but if I don't, then it does not space
                    #correctly
                    if i<(len(data)-1):
                        dataLine2+=wSpace[8-len(data[i])]
                        dataLine2+=data[i]
                    else:
                        dataLine2+=wSpace[9-len(data[i])]
                        dataLine2+=data[i]
#                    print(data[i])
#                print(dataLine2)
#                    debugLine=dataLine2
#            print(dataLine)
#            print(dataLine2)
                    
            #Write CTETRA to file
            finalLine=dataLine.replace('\n','')
#            finalLine=finalLine+'\n'
#            print(finalLine)
            writeFile.write(finalLine)
            finalLine2=dataLine2.replace('\n','')
#            print(finalLine2)
            finalLine2=finalLine2+'\n'
            writeFile.write(finalLine2)

#Open the file with the shell data
with open(shellFilePath) as file:
    for line in file:
#        print(line)
        
        #Store the data to be written to the formatted file
        dataLine=''
        dataLine2='' #For rollover elements
        
        #Split each line into an array
        data=line.split(',')
        #Delete unnecessary values
        data=list(filter(None,data))
        for item in data:
            if item=='\n':
                data.remove(item)
                
        #Create data lines for CTRIA6
        if data[0]=='CTRIA6':
            
            dataLine='CTRIA6  '
            for i in range(1,3):
                dataLine+=wSpace[8-len(data[i])]
                dataLine+=data[i]
            
            #Find the correct grid number
            for i in range(3,len(data)):
                #Get the line containing co-ordinate data
                dataStr=','+data[i]+','
                #Find starting index
                startIndex=shellFile.find(str.encode(dataStr))
                #Find the final index
                endIndex=shellFile.find(b'\n',startIndex)
                #Extract the grid point data
                gridStr=shellFile[startIndex:endIndex].decode()
                gridArr=gridStr.split(',')
                #Construct the string to search for in the body file
                searchStr=','
                for i in range(3,6):
                    searchStr+=gridArr[i]+','
                #Search for string in the body file
                endIndexBody=bodyFile.find(str.encode(searchStr))
                startIndexBody=bodyFile.rfind(str.encode('D'),0,endIndexBody)
                trueGrid=''
                #Account for a point if it is not in the body file
                #
                #This happens because the program is not reading from the
                #correct file. This is addressed further down
                if endIndexBody==-1:
                    #Store missing GRID points
                    #NOTE: This creates duplicates in mPoints. This is helpful
                    #when fixing the data entry
                    mPoints.append(dataStr[1:-1])
                    #Add a placeholder for the missing point
                    trueGrid=dataStr[1:-1]+'***'
                elif endIndexBody!=-1:
                    trueGridStr=bodyFile[startIndexBody:endIndexBody].decode()
                    trueGridArr=trueGridStr.split(',')
                    trueGrid=trueGridArr[1]
                #Add the corrected grid point to dataLine
                dataLine+=wSpace[8-len(trueGrid)]+trueGrid
            
#            #Compare the old and new data lines
#            print(line)
#            print(dataLine)
                
            #Write CTRIA6 to file
            finalLine=dataLine+'\n'
            writeFile.write(finalLine)
            
        #Create data lines for PSHELL
        elif data[0]=='PSHELL':
            #Add the starting comment to indicate PSOLID data
            if pshellFlag==False:
                writeFile.write('$ Property data section\n')
                pshellFlag=True
                
            dataLine+='PSHELL  '
            for i in range(1,len(data)):
                dataLine+=wSpace[8-len(data[i])]
                dataLine+=data[i]
            
            #Write PSOLID to file
            finalLine=dataLine+'\n'
            writeFile.write(finalLine)
        
#Print the missing points
print(mPoints)

#Write the end-line
writeFile.write('ENDDATA')
writeFile.close()

#Open the edited file to fix the following issues
#1. Find and fix the GRID data with ***
#2. Delete any triangles with zero area

#Make the formatted file easily searchable
formattedFileObj=open(formattedFilePath)
formFile=mmap.mmap(formattedFileObj.fileno(),0,access=mmap.ACCESS_READ)

#Stores the values of the corrected GRID points
mPointsNew=[]

#Go through each point in mPoints and fix its entry in rings_formatted.txt
for num in mPoints:
    #Stores the minimum distance and grid number
    minDist=100 #Set arbitrarily large
    gridPoint=''
    
    #Get the point data from the shell file
    startIndexShell=shellFile.find(str.encode(str(num)))
    endIndexShell=shellFile.find(b'\n',startIndexShell)
    pData=shellFile[startIndexShell:endIndexShell].decode()
    pDataArr=pData.split(',')[2:5]
    pDataArrInt=[]
    #Convert strings into integers
    for i in pDataArr:
        pDataArrInt.append(numConv(i,5))
        
    #Go through the formatted file and find the closest point
    with open(bodyFilePath) as file:
        for line in file:
            #Split each line into an array
            data=line.split(',')
            #Delete unnecessary values
            data=list(filter(None,data))
            for item in data:
                if item=='\n':
                    data.remove(item)
            if data[0]=='GRID':
                #Get the co-ordinate values
                dataArr=data[3:6]
                dataArrInt=[]
                for i in dataArr:
                    dataArrInt.append(numConv(i,5))
#                print(dataArrInt)
                #Get distance between GRID points
                dist=distPoints(pDataArrInt,dataArrInt)
                if dist<minDist:
                    #Store closest GRID point
                    minDist=dist
                    gridPoint=data[1]
#    print(minDist)
#    print(gridPoint)
    #Add corrected GRID point to the array
    mPointsNew.append(gridPoint)
    
#Go through the file line by line and edit any bad entries
with open(formattedFilePath) as file:
    cIndex=0#Track the corrected point
    for line in file:
#        print(line)
        if 'CTRIA6' in line:
            #Run 6 times to account for worst case of each number being wrong
            for i in range (0,7):
                #Check if the line is a bad data point
                if '***' in line:
                    #Find the index of the bad GRID point in the line
                    endIndex=line.find('***')+3
                    startIndex=line.rfind(' ',0,endIndex)
                    lenStr=endIndex-startIndex
                    #Correct for whitespace
                    newStr=wSpace[lenStr-len(mPointsNew[cIndex])]+mPointsNew[cIndex]
                    line=line.replace(line[startIndex:endIndex],newStr)
                    cIndex+=1
            #Check if the shape is flat
            lineArr=line.split('    ')[3:9]
            #Convert strings to integers
            lineArrInt=[] #Stores triangle vertices
            for item in lineArr:
                lineArrInt.append(int(item))
            #See if any 2 items in lineArrInt match
            for item in lineArrInt:
                if lineArrInt.count(item)>1:
                    line=''
            #Check to see if the CTRIA triangle matches a CTETRA triangle
            triFlag=False #If true, the CTRIA triangle is present in the file
            with open(formattedFilePath) as file2:
                for line2 in file2:
                    if 'CTETRA' in line2:
                        #Extract tetrahedra vertices
                        lineArr2=line.split(',')[3:7]
                        #Convert to integers
                        lineArrInt2=[] #Stores the tetrahedra vertices
                        for item in lineArr2:
                            lineArrInt2.append(int(item))
                        #Get 3 triangles from 4 vertices
                        triArr=list(itertools.combinations(lineArrInt2,3))
                        for tri in triArr:
                            triFlag=arrEq(tri,lineArrInt[:3])
            if triFlag==False:
                line=''
            else:
                print(triFlag)
        writeFile2.write(line)

writeFile2.close()